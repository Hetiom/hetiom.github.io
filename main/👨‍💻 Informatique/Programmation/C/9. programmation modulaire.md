
# Information utiles
*Source :* [openclassrooms-forum](https://openclassrooms.com/forum/sujet/fichier-h-et-fichier-c)
```
La Compilation, j'entends preprocesseur +  compilation + le linkage :

1)
Toute les instruction de préprocesseur sont évalue et font leurs jobs.  
Par exemples, "#include fichier" permet de copier le contenue de "fichier" à la place de #include.  
Ca remplace la ligne par le contenue du fichier, carrément.  

2)
la compilation (qui ne s'effectue QUE sur les fichiers .c).  
À chaque fois que le compilateur commence à un compiler un fichier, il "oublie" tout : il ne connaît plus les fonctions, les variables, etc etc.  
Il part du haut du fichier, et descend ligne par ligne en faisant ses vérifications (syntaxique, sémantique, etc etc).  
Quand il tombe sur le prototype d'une fonction, il "retient" cette dernière en mémoire (son nom, son type de retour ...).  
Quand il tombe sur un appel de fonction, il regarde dans sa mémoire s'il la connaît.  
Si oui, pas de soucis (à moins que mauvais nombre d'argument, retour mal utilisé, mais ça c'est la vérification syntaxique et sémantique).  
Si non, il va émettre un avertissement de type "implicite declaration of function 'nom'.  
  
Mais il est possible que cela n'arrête pas la compilation : le compilateur va considérer que puisqu'il ne la connaît pas, c'est une fonction qui retourne un int et qui prends aucun arguments, et si d'aventure c'est correct sémantiquement (par exemple, la variable qui récupère le retour de la fonction est "compatible" avec un int, c'est ok), alors la compilation se poursuivra.  
  
3) 
C'est au tour du linker. Le linker va prendre tout les .o (c'est les .c compilés) et les assembler.  
C'est a ce moment que le linker va vérifier si chaque fonctions utilisé dans les .c existe.  
Typiquement, tu as la fonction "position" défini dans "position.c", et utilisé dans "main.c".  
le linker va vérifier que la fonction "position" appelé dans "main.c" existe bien et en un seul exemplaire.  
Si ce n'est pas le cas, il émettra un erreur (et la ça arrête tout) de type "undefined reference to 'untel'".  
  
Pour que le compilateur puisse connaitre les prototype de fonction dans chaque .c, on déclare simplement le prototype dans un .h que l'on inclue au debut du fichier .c.  
Ainsi, à l'étape du préprocesseur, le contenue du .h (et donc le prototype de la fonction) est copié au debut du .c, à l'étape de compilation, le compilateur va connaitre la fonction (et n'émettra pas de warning).
```


# Les .h
*Syntaxe :*
```C
#ifndef nom_fichier_H // en majuscule avec underscore
#define nom_fichier_H // en majuscule avec underscore

prototype_de_la_fonction();

#endif
```

# Les .c
*Syntaxe :*
```C
#include "fichier.h"

#include autres includes

fonction()
{
	// Instructions;
}
```

# Compilation
***Avec gcc :***
```bash
gcc *.c -o nom_de_l_executable
```
